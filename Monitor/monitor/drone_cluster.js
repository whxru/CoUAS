/**
 * @file Implement some methods to manage multiple drone connections.
 * @author whxru
 */

const { Drone } = require('./drone');
const dgram = require('dgram');
const events = require('events');
const transform = require('./lib/transform');
const myConsole = require('../monitor-app/module/console');
const { MAVC } = require('./lib/mavc');
// For the use of private attributes
const _port = Symbol('port');
const _drones = Symbol('drones');
const _drone = Symbol('drone');
const _publicIp = Symbol('publicIp');
const _broadcastAddr = Symbol('broadcastAddr');
// For the use of private methods
const _addNotification = Symbol('addNotification');
const _sendSubtasks = Symbol('sendSubtasks');

/**
 * Management of mulitple drone connections.
 * @class DroneCluster
 */
class DroneCluster {
    /**
     * Creates an instance of DroneCluster.
     * @param {String} interfaceName - Name of network interface will be used
     * @memberof DroneCluster
     */
    constructor(interfaceName) {
        this[_port] = 4396; // Port on Pi where the message will be sent to
        this[_drones] = []; // Container of drones
        this[_drone] = new events.EventEmitter();

        // Calculate broadcast address
        var iface = require('os').networkInterfaces()[interfaceName];
        var ipv4Addr = null;
        var netmask = null;
        iface.forEach((addr) => {
            if(addr['family'] === 'IPv4') {
                ipv4Addr = addr['address'];
                netmask = addr['netmask']
            }
        })
        this[_publicIp] = ipv4Addr;
        this[_broadcastAddr] = DroneCluster.getBroadcastAddr(ipv4Addr, netmask);
    }

    /**
     * Generate a unique CID and send to the Pi.
     * New an instance of Drone (send the CID as soon as the request arrived).
     * @summary Add one single drone into the cluster
     * @memberof DroneCluster
     * @param {Number} [num=1] - Number of drones to be added
     */
    addDrone(num=1) {
        // Generate CID
        var CID_base = this[_drones].length;

        if(num > 1) {
            // Add sitls to the container
            for(let i=CID_base; i<CID_base + num; i++) {
                var drone = new Drone(CID_base+i+1, this[_publicIp], true);
                this[_drones].push(drone);
                this[_addNotification](drone.getEventNotifier());
            }
        } else {
            var drone = new Drone(CID_base + 1, this[_publicIp], false);
            this[_drones].push(drone)
            this[_addNotification](drone.getEventNotifier());
        }
    }


    /**
     * Decompose current task into serveral subtasks and send them.
     * @param {String} task_json - JSON string contains all of the actions 
     * @memberof DroneCluster
     */
    executeTask(task_json) {
        if (!DroneCluster.isTaskString(task_json)) {
            return;
        }
        // Get actions in the task
        var actions = JSON.parse(task_json);

        // Transform from GCJ-02 to WGS-84 in GO_TO action
        actions.forEach((action) => {
            if(action['Action_type'] === MAVC.ACTION_GO_TO) {
                var pos_wgs = transform.gcj2wgs(action.Lat, action.Lon);
                action['Lat'] = pos_wgs.lat;
                action['Lon'] = pos_wgs.lng;
            }
        })

        // Decompose current task into several subtasks
        var subtasks = [];
        var indexes = []; // Which subtask the drone currently in 
        this[_drones].forEach(() => { indexes.push(0) });
        // There is at least one subtask
        subtasks.push([
            {
                "Header": "MAVCluster_Monitor",
                "Type": MAVC.MAVC_ACTION
            }
        ]);
        while (actions.length > 0) {
            // Push action into current subtask
            var action = actions[0];
            var index = indexes[action.CID - 1];
            subtasks[index].push(action);
            // Shift action from the origin task away
            actions.shift();
            // Update index if needed
            if (action['Sync'] === true) {
                index = ++indexes[action.CID - 1];
                // Create next subtask if needed
                if (index >= subtasks.length) {
                    subtasks.push([
                        {
                            "Header": "MAVCluster_Monitor",
                            "Type": MAVC.MAVC_ACTION
                        }
                    ]);
                }
            }
        }
        // An empty subtask may be created
        if (subtasks[subtasks.length - 1].length === 1) {
            subtasks.pop();
        }

        // Send subtasks
        this[_sendSubtasks](subtasks);
    }

    /**
     * Clear all the traces generated by last task.
     * @memberof DroneCluster
     */
    clearTrace() {
        this[_drones].forEach((drone) => {
            drone.clearTrace();
        });
    }
    
    /**
     * Set the geofence of cluster
     * @param {Number} rad - Radius of the circle 
     * @param {Number} lat - Latitude of the center
     * @param {Number} lon - Longitude of the center
     * @memberof DroneCluster
     */
    setGeofence(rad, lat, lon) {
        var msg = [
            {
                "Header": "MAVCluster_Monitor",
                "Type": MAVC.MAVC_SET_GEOFENCE
            },
            {
                "Radius": rad,
                "Lat": lat,
                "Lon": lon
            }
        ];
        this.broadcastMsg(msg);
    }

    /**
     * Get public ip and address for broadcast.
     * @returns Object that contains public ip and address for broadcast
     * @memberof DroneCluster
     */
    getConnectionInfo() {
        return {
            'publicIp': this[_publicIp],
            'broadcastAddr': this[_broadcastAddr]
        }
    }

    /**
     * Get distance of every drone in a task.
     * @returns Total distance
     * @memberof DroneCluster
     */
    getDistances() {
        var distances = [];
        this[_drones].forEach((drone) => {
            distances.push(drone.getDistance());
        });
        return distances;
    }

    /**
     * Get the event emitter.
     * @returns Event emitter.
     * @memberof DroneCluster
     */
    getNotifier() {
        return this[_drone];
    }
    
    /**
     * Get the object of drone according to the CID.
     * @param {Number} CID - Connection ID
     * @returns {Object} The object of drone.
     * @memberof DroneCluster
     */
    getDrone(CID) {
        if(CID > this[_drones].length -1) {
            return null;
        }
        return this[_drones][CID];
    }

    /**
     * Get the number of drones in the cluster.
     * @returns {Number} Number of drones
     * @memberof DroneCluster
     */
    getDroneNum() {
        return this[_drones].length;
    }
    

    /**
     * Send message to every drone in the cluster.
     * @param {Object} msg - MAVC message
     * @memberof DroneCluster
     */
    broadcastMsg(msg) {
        var msg_json = JSON.stringify(msg);
        this[_drones].forEach((drone) => {
            drone.writeDataToPi(msg_json);
        })
    }

    /**
     * Collect the nofication of drones in the cluster.
     * @param {EventEmitter} drone - The event emitter of one single drone.
     * @memberof DroneCluster
     */
    [_addNotification](drone) {
        drone.on('message-in', (CID, msg_obj) => {
            this.getNotifier().emit('message-in', CID, msg_obj);
        });
        
        drone.on('message-out', (CID, msg_obj) => {
            this.getNotifier().emit('message-out', CID, msg_obj);
        });

        drone.on('new-drone-add', () => {
            this.getNotifier().emit('new-drone-add');
        });
    }

    /**
     * Send subtasks one by one.
     * @param {Object} subtasks - MAVC.MAVC_ACTION message of subtasks
     * @memberof DroneCluster
     */
    [_sendSubtasks](subtasks) {
        // Send first subtask
        this.broadcastMsg(subtasks[0]);
        // Wait for all actions having been performed
        var index = 0;                          // Which subtask the cluster currently in.
        var counter = 0;                        // Number of drones which has been ready for next subtask.
        var droneNum = this[_drones].length;    // Total number of drones.
        let cls_subtasks = subtasks;            // Used in closure.
        this[_drones].forEach((drone) => {
            var notifier = drone.getEventNotifier();
            // One of the drones has finished performing actions in current subtask
            notifier.on('arrive', (notifier) => {
                if (++counter === droneNum) {
                    myConsole.log("Go to next subtask");
                    // Empty the counter
                    counter = 0;
                    // Execute next subtask
                    if (++index < cls_subtasks.length) {
                        this.broadcastMsg(cls_subtasks[index]);
                    }
                }
            });
        });
    }

    /**
     * Caculate the address of broadcast
     * @static
     * @param {String} ipv4Addr - IPv4 address
     * @param {String} netmask - Netmask
     * @returns {string} Broadcast address
     * @memberof DroneCluster
     */
    static getBroadcastAddr(ipv4Addr, netmask) {
        var addrParts = ipv4Addr.split('.');
        var maskParts = netmask.split('.');
        var broadcastAddr = '';
        for (let n = 0; n < 4; n++) {
            var partAddr = '';

            var addr = ('00000000' + parseInt(addrParts[n]).toString(2)).substr(-8);
            var mask = ('00000000' + parseInt(maskParts[n]).toString(2)).substr(-8);
            for (let m = 0; m < 8; m++) {
                if (mask[m] === '0') {
                    partAddr += '1';
                } else {
                    partAddr += addr[m];
                }
            }

            broadcastAddr += parseInt(partAddr, 2).toString();
            if (n < 3) {
                broadcastAddr += '.';
            }
        }

        return broadcastAddr;
    }

    /**
     * To judge whether the string descrips a MAVC task
     * @static
     * @param {String} str - String to be judged
     * @returns The result of judgment
     * @memberof DroneCluster
     * @todo Implementation
     */
    static isTaskString(str) {
        return true;
    }
}

module.exports.DroneCluster = DroneCluster;